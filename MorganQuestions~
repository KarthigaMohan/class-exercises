
1. How HashMap works in Java? 
HashMap is the most used data structure in java because it gives almost constant time performance of O(1) for put and get operations irrespective of how big is the data.HashMap stores the data in the form of key-value pairs. Each key-value pair is stored in an object of Entry<K, V> class. Entry<K, V> class is the static inner class of HashMap. 
	This inner class has four fields. key, value, next and hash.
		key : It stores the key of an element and its final.
		value : It holds the value of an element.
		next : It holds the pointer to next key-value pair. This attribute makes the key-value pairs stored as a linked list.
		hash : It holds the hashcode of the key.
 All these Entry<K, V> objects are stored in an array called table[]. 
It doesn’t inserts the objects as you put them into HashMap i.e first element at index 0, second element at index 1 and so on. Instead it uses the hashcode of the key to decide the index for a particular key-value pair. It is called Hashing.


2. Count the occurrences of numbers in an array
Use Arrays.sort() to arrange them in an order. Once the element is found, keep counting until the next element is different. Then stop and return count. 



3. What is the difference between JDK 1.5 and JDK 1.4?
The major enhancement for JDK 1.5 version

1. Generics
2. Enhanced for loop
3. Autoboxing/Unboxing
4.Type Safe Enums
5. Varargs
6. Static import
7. Annotations


4. What is the HashCode and Equal method?
In java equals() method is used to compare equality of two Objects. The equality can be compared in two ways:

	Shallow comparison: The default implementation of equals method is defined in Java.lang.Object class which simply checks if two Object 			references (say x and y) refer to the same Object. i.e. It checks if x == y. Since Object class has no data members that 			define its state, it is also known as shallow comparison.
   	Deep Comparison: Suppose a class provides its own implementation of equals() method in order to compare the Objects of that class 			w.r.t state of the Objects. That means data members (i.e. fields) of Objects are to be compared with one another. Such 			Comparison based on data members is known as deep comparison.

HashCode() returns the hashcode value as an Integer. Hashcode value is mostly used in hashing based collections like HashMap, HashSet, HashTable….etc. This method must be overridden in every class which overrides equals() method.


5. Talk about the database. 
Database is a systematic collection of data. Databases support storage and  manipulation of data. Database Management System (DBMS) is a collection of programs which enables its users to access database, manipulate data, reporting / representation of  data .
It also helps to control access to the  database. 4 Types:
	Hierarchical: This type of DBMS employs the "parent-child" relationship of storing data.
	Network DBMS: This type of DBMS supports many-to many relations.  
	Relational DBMS: This type of DBMS defines database relationships in form of tables, also known as relations. 
	Object Oriented Relation DBMS: This type supports storage of new data types.


6. What is index, the advantage and disadvantage?
Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. 
	Advantage: 
		Their use in queries usually results in much better performance.
    		They make it possible to quickly retrieve (fetch) data i.e SELECT and WHERE clauses. 
    		They can be used for sorting. A post-fetch-sort operation can be eliminated.
    		Unique indexes guarantee uniquely identifiable records in the database.
	Disadvantage: 
		Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). 			They decrease performance on inserts, updates, and deletes.
   		They take up space (this increases with the number of fields used and the length of the fields).
    		Some databases will monocase values in fields that are indexed.




7. What is left join? 
The SQL LEFT JOIN returns all rows from the left table, even if there are no matches in the right table. This means that if the ON clause matches 0 (zero) records in the right table; the join will still return a row in the result, but with NULL in each column from the right table.



8. In database: describe the 1NF, 2NF and 3NF. 
1NF (First Normal Form) Rules
    Rule 1-Each table cell should contain a single value.
    Rule 2-Each record needs to be unique.

2NF (Second Normal Form) Rules 
    Rule 1- Be in 1NF
    Rule 2- Single Column Primary Key

3NF (Third Normal Form) Rules
    Rule 1- Be in 2NF
    Rule 2- Has no transitive functional dependencies


9. Given a relational database, how to improve the performance of a select query involving some joins? 
	Use inner join, instead of outer join if possible.
		The outer join should only be used if it is necessary. Using outer join limits the database optimization options which 			typically results in slower SQL execution.
	For SQL queries with the LEFT OUTER JOIN, pushing predicates of the right table from the WHERE clause into the ON condition helps the 			database optimizer generate a more efficient query. Predicates of the left table can stay in the WHERE clause.
	Similarly, for the SQL queries with the RIGHT OUTER JOIN, predicates for the right table should be moved from the WHERE clause into 			the ON condition.

10. Composition vs aggregation. 
The three types of association connectors: association, aggregation and composition. 
    Aggregation implies a relationship where the child can exist independently of the parent. Example: Class (parent) and Student (child). Delete the Class and the Students still exist.f two classes in a model need to communicate with each other, there must be link between them, and that can be represented by an association (connector). 
    Composition implies a relationship where the child cannot exist independent of the parent. Example: House (parent) and Room (child). Rooms don't exist separate to a House. We should be more specific and use the composition link in cases where in addition to the part-of relationship between Class A and Class B - there's a strong lifecycle dependency between the two, meaning that when Class A is deleted then Class B is also deleted as a result


11. Overloading vs Overriding. 
1). The real object type in the run-time, not the reference variable's type, determines which overridden method is used at runtime. In contrast, reference type determines which overloaded method will be used at compile time.
2). Polymorphism applies to overriding, not to overloading.
3). Overriding is a run-time concept while overloading is a compile-time concept.  
4)Method overloading is used to increase the readability of the program.	Method overriding is used to provide the specific implementation of the method that is already provided by its super class.
5)Method overloading is performed within class.	Method overriding occurs in two classes that have IS-A (inheritance) relationship.
6)In case of method overloading, parameter must be different.	In case of method overriding, parameter must be same.
7)Method overloading is the example of compile time polymorphism.	Method overriding is the example of run time polymorphism.
8)In java, method overloading can't be performed by changing return type of the method only. Return type can be same or different in method overloading. But you must have to change the parameter.	Return type must be same or covariant in method overriding.


12. How to implement final keyword in java ?
You are always allowed to initialize a final variable. The compiler makes sure that you can do it only once.
Note that calling methods on an object stored in a final variable has nothing to do with the semantics of final. In other words: final is only about the reference itself, and not about the contents of the referenced object.

There are three ways to initialize a final variable :

    You can initialize a final variable when it is declared.This approach is the most common. A final variable is called blank final variable,if it is not initialized while declaration. Below are the two ways to initialize a blank final variable.
    A blank final variable can be initialized inside instance-initializer block or inside constructor. If you have more than one constructor in your class then it must be initialized in all of them, otherwise compile time error will be thrown.
    A blank final static variable can be initialized inside static block. 

When a final variable is a reference to an object, then this final variable is called reference final variable.But in case of a reference final variable, internal state of the object pointed by that reference variable can be changed. Note that this is not re-assigning. This property of final is called non-transitivity. 





13. Why String class is specific in Java?
1. Requirement of String Pool
	String pool (String intern pool) is a special storage area in Java heap. When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object and returning its reference.If string is not immutable, changing the string with one reference will lead to the wrong value for the other references.

2. Allow String to Cache its Hashcode
	The hashcode of string is frequently used in Java. For example, in a HashMap. Being immutable guarantees that hashcode will always the same, so that it can be cashed without worrying the changes.That means, there is no need to calculate hashcode every time it is used. This is more efficient.

3. Security
	String is widely used as parameter for many java classes, e.g. network connection, opening files, etc. Were String not immutable, a connection or file would be changed and lead to serious security threat.




14. 


 
